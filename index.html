<html>

<body>
    <canvas id="canvas"></canvas>
    <style>
        canvas {
            width: 1200px;
            height: 800px;
            border: 1px solid black;
            margin: 0 auto;
        }
    </style>
    <script>
        const P = 4; // number of sides of polygon
        const Q = 6; // number of polygons that meet at each vertex

        // Connection rules for the tessellation with Schlafli symbol {p,q}, in counterclockwise order.
        // See Section 2 of "Generating Tree Structures for Hyperbolic Tessellations" by D Celińska-Kopczyńska, https://arxiv.org/pdf/2111.12040.pdf.
        const CONNECTION_RULES = {
            '{4,5}': [[1, 1, 1, 1], ['P', 3, 1, 2], ['P', 3, 1, 'L'], ['P', 'R', 3, 2]],
            '{4,6}': [[1, 1, 1, 1], ['P', 3, 1, 2], ['P', 3, 1, 4], ['P', 'R', 1, 2], ['P', 3, 1, 'L']],
        }[`{${P},${Q}}`];

        function generateMap(maxDepth) {
            const map = [{ state: 0, depth: 0, neighbors: new Array(P) }];

            function connect(nodeIndex1, returnNeighborIndex1, nodeIndex2, returnNeighborIndex2) {
                map[nodeIndex1].neighbors[returnNeighborIndex1] = { nodeIndex: nodeIndex2, returnNeighborIndex: returnNeighborIndex2 };
                map[nodeIndex2].neighbors[returnNeighborIndex2] = { nodeIndex: nodeIndex1, returnNeighborIndex: returnNeighborIndex1 };
            }

            function generateMapHelper(nodeIndex, neighborIndex) {
                const { state, depth, neighbors } = map[nodeIndex];
                if (depth === maxDepth || neighbors[neighborIndex] !== undefined) {
                    return;
                }
                const nextState = CONNECTION_RULES[state][neighborIndex];
                if (typeof (nextState) === 'number') {
                    const node = { state: nextState, depth: depth + 1, neighbors: new Array(P) };
                    const newNodeIndex = map.length;
                    map.push(node);
                    connect(nodeIndex, neighborIndex, newNodeIndex, 0);
                    for (let i = 0; i < P; i++) {
                        generateMapHelper(newNodeIndex, i);
                    }
                } else {
                    const d = { 'L': 1, 'R': P - 1 }[nextState];
                    let edge = { nodeIndex, returnNeighborIndex: neighborIndex };
                    for (let k = 0; k < Q - 1; k++) {
                        const neighborIndex = (edge.returnNeighborIndex + d) % P;
                        generateMapHelper(edge.nodeIndex, neighborIndex);
                        edge = map[edge.nodeIndex].neighbors[neighborIndex];
                        if (edge === undefined) {
                            return;
                        }
                    }
                    connect(nodeIndex, neighborIndex, edge.nodeIndex, (edge.returnNeighborIndex + d) % P);
                }
            }

            for (let i = 0; i < P; i++) {
                generateMapHelper(0, i);
            }
            return map;
        }

        /* rendering */

        function sinh(x) {
            return (Math.exp(x) - Math.exp(-x)) / 2;
        }

        function cosh(x) {
            return (Math.exp(x) + Math.exp(-x)) / 2;
        }

        function acosh(x) {
            return Math.log(x + Math.sqrt(x * x - 1));
        }

        function asinh(x) {
            return Math.log(x + Math.sqrt(x * x + 1));
        }

        const WIDTH = 1200;
        const HEIGHT = 800;
        const SCALE = 150;
        const NUM_STEPS = 10;
        const EPS = 1e-12;

        // Note these expressions are only valid for P=4
        const COT = Math.cos(Math.PI / Q) / Math.sin(Math.PI / Q);
        const K = 1 / acosh(COT * COT); // Gaussian curvature
        const R = K * acosh(COT); // radius from center of polygon to vertex
        const D = 2 * K * asinh(Math.sin(Math.PI / Q) * sinh(1 / (2 * K)) * Math.sqrt(2)); // distance between centers of adjacent polygons

        function from_polar(r, θ) {
            return [WIDTH / 2 + SCALE * r * Math.cos(θ), HEIGHT / 2 - SCALE * r * Math.sin(θ)];
        }

        function move(start_r, start_θ, len, heading) {
            if (start_r === 0) {
                return [len, heading, heading];
            }
            const ϕ = (start_θ + Math.PI - heading) % (2 * Math.PI);
            const crossProductSignum = ϕ < -Math.PI || (ϕ > 0 && ϕ < Math.PI) ? 1 : -1;
            const r = K * acosh(cosh(len / K) * cosh(start_r / K) - sinh(len / K) * sinh(start_r / K) * Math.cos(ϕ));
            const θ = Math.acos((cosh(r / K) * cosh(start_r / K) - cosh(len / K)) / (sinh(r / K) * sinh(start_r / K) * (1 + EPS)))
                * crossProductSignum
                + start_θ;
            const newHeading = Math.acos((cosh(r / K) * cosh(len / K) - cosh(start_r / K)) / (sinh(r / K) * sinh(len / K) * (1 + EPS)))
                * crossProductSignum
                + θ;
            return [r, θ, newHeading];
        }

        function drawStraightLine(ctx, x1, y1, x2, y2) {
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawLine(ctx, start_r, start_θ, len, heading) {
            ctx.strokeStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(...from_polar(start_r, start_θ));
            for (let step = 1; step <= NUM_STEPS; step++) {
                const [r, θ, newHeading] = move(start_r, start_θ, len * step / NUM_STEPS, heading);
                ctx.lineTo(...from_polar(r, θ));
            }
            ctx.stroke();
        }

        function drawPolygon(ctx, center_r, center_θ, heading) {
            for (let i = 0; i < P; i++) {
                const [r, θ, localHeading] = move(center_r, center_θ, R, heading + 2 * Math.PI * (i + .5) / P);
                drawLine(ctx, r, θ, 1, localHeading + Math.PI - Math.PI / Q);
            }
        }

        function drawMap(ctx, map, startNodeIndex, startNode_r, startNode_θ) {
            function drawMapHelper(nodeIndex, r, θ, heading, returnNeighborIndex) {
                const { state, neighbors } = map[nodeIndex];
                drawPolygon(ctx, r, θ, heading);
                for (let i = 0; i < P; i++) {
                    if (typeof(CONNECTION_RULES[state][i]) === 'number' && neighbors[i] !== undefined) {
                        const { nodeIndex: newNodeIndex, returnNeighborIndex: newReturnNeighborIndex } = neighbors[i];
                        const [new_r, new_θ, newHeading] = move(r, θ, D, heading + (2 * (i - returnNeighborIndex) / P + 1) * Math.PI);
                        drawStraightLine(ctx, ...from_polar(r, θ), ...from_polar(new_r, new_θ));
                        drawMapHelper(newNodeIndex, new_r, new_θ, newHeading, newReturnNeighborIndex);
                    }
                }
            }

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            drawMapHelper(startNodeIndex, startNode_r, startNode_θ, 0, P);
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        const map = generateMap(4);
        console.log('map length:', map.length);

        console.time('draw map');
        drawMap(ctx, map, 0, 2, 0);
        console.timeEnd('draw map');
    </script>
</body>

</html>
