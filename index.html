<html>

<head>
    <title>Patrick's Hyperbox</title>
    <meta charset="UTF-8">
    <meta name="Description" content="Patrick's Parabox in hyperbolic space">
    <style>
        .canvas-holder {
            position: relative;
            border: 1px solid black;
            width: 1200px;
            height: 800px;
        }

        .level-select {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        #current-level {
            width: 250px;
            height: 70px;
            font-size: 60px;
        }

        #level-list {
            position: absolute;
            display: none;
        }

        #level-list * {
            font-size: 32px;
        }

        .level-select:hover #level-list {
            display: block;
        }

        .key {
            position: absolute;
            width: 80px;
            height: 80px;
            font-size: 60px;
        }
    </style>
</head>

<body>
    <div class="canvas-holder">
        <canvas id="canvas"></canvas>
        <div class="level-select">
            <input id="current-level" type="button" value="" onclick="initializeLevel(level);" />
            <div id="level-list"></div>
        </div>
        <input type="button" class="key" style="bottom: 10px; right: 10px;" value="→" onclick="moveDir(0);" />
        <input type="button" class="key" style="bottom: 100px; right: 100px;" value="↑" onclick="moveDir(1);" />
        <input type="button" class="key" style="bottom: 10px; right: 190px;" value="←" onclick="moveDir(2);" />
        <input type="button" class="key" style="bottom: 10px; right: 100px;" value="↓" onclick="moveDir(3);" />
    </div>
    <script src="./math.js"></script>
    <script src="./treePath.js"></script>
    <script src="./map.js"></script>
    <script src="./rendering.js"></script>
    <script src="./serialization.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        let latestLevel = parseInt(localStorage.getItem('latestLevel') || 1);
        let level;
        let gameMap;
        let polygons;
        let animationMap = new Map();
        let animationStep = 0;

        initializeLevel(window.location.hash ? -1 : parseInt(localStorage.getItem('level') || 1));

        function initializeLevel(newLevel) {
            level = newLevel;
            localStorage.setItem('level', level);
            if (level > latestLevel) {
                latestLevel = level;
                localStorage.setItem('latestLevel', latestLevel);
            }

            let innerHTML = '';
            for (let i = 1; i <= latestLevel; i++) {
                if (i !== level) {
                    innerHTML += `<input type="button" value="Go to level ${i}" onclick="initializeLevel(${i});" />`;
                }
            }
            document.getElementById('level-list').innerHTML = innerHTML;

            if (level === -1) {
                document.getElementById('current-level').value = 'Custom';
                gameMap = deserialize(atob(window.location.hash.substring(1)));
                gameMapInitialized();
            } else {
                document.getElementById('current-level').value = `Level ${level}`;
                fetch(`./levels/${level.toString().padStart(2, '0')}.txt`)
                    .then(data => data.text())
                    .then(text => {
                        gameMap = deserialize(text);
                        gameMapInitialized();
                    });
            }
        }

        function gameMapInitialized() {
            polygons = getPolygons(gameMap);
            updateAnimationMap(polygons, animationMap);
            render(canvas, polygons);
        }

        function animate() {
            if (animationStep > 0) {
                animationStep--;
                setTimeout(animate, 40);
                render(canvas, polygons, animationMap, animationStep)
                if (animationStep === 0) {
                    updateAnimationMap(polygons, animationMap);
                }
            } else if (gameMap !== undefined && isWin(gameMap)) {
                gameMap = undefined;
                alert('You win!');
                initializeLevel(level === -1 ? -1 : level + 1);
            }
        }

        function getRootToPlayerPath() {
            const down = [];
            let ref = gameMap.refs.find(r => gameMap.blocks[r.blockIndex].player && r.exitBlock);
            // TODO determine correct bounds here
            for (let i = 0; i < 5; i++) {
                down.unshift(ref.parentNode);
                ref = gameMap.refs.find(r => r.blockIndex === ref.parentNode.blockIndex && r.exitBlock);
                if (ref === undefined) {
                    break;
                }
            }
            return new TreePath([], down);
        }

        function isValidConcat(treePath1, treePath2) {
            for (let i = 0; i < treePath2.up.length; i++) {
                if (treePath1.down[treePath1.down.length - 1 - i] !== treePath2.up[treePath2.up.length - 1 - i]) {
                    return false;
                }
            }
            return true;
        }

        function moveDir(dir) {
            if (animationStep !== 0) {
                return;
            }

            const rootToPlayerPath = getRootToPlayerPath();
            const { moves, playerMove } = movePlayer(gameMap, dir);
            const newAnimationMap = new Map();
            for (const { treePath, extraValue, points } of animationMap.values()) {
                let newTreePath = treePath;
                for (const move of moves) {
                    // TODO it's also possible for an ancestor to have moved, not just this node itself
                    if (isValidConcat(rootToPlayerPath.concat(treePath), move)) {
                        newTreePath = treePath.concat(move);
                        break;
                    }
                }
                newTreePath = playerMove.reverse().concat(newTreePath);
                newAnimationMap.set(newTreePath.hash(extraValue), { newTreePath, extraValue, points });
            }
            animationMap = newAnimationMap;
            animationStep = NUM_ANIMATION_STEPS;
            polygons = getPolygons(gameMap, dir);
            animate();
        }

        document.addEventListener('keydown', e => {
            const dir = {
                ArrowRight: 0, ArrowUp: 1, ArrowLeft: 2, ArrowDown: 3,
                KeyD: 0, KeyW: 1, KeyA: 2, KeyS: 3,
            }[e.code];
            if (dir !== undefined) {
                moveDir(dir);
                e.preventDefault();
            }
        });
    </script>
</body>

</html>
